# Commit Audit: 70904c4e932bbc4d0b04196bad24376d4c41feee

**Date**: 2026-01-23  
**Commit**: 70904c4e932bbc4d0b04196bad24376d4c41feee  
**Branch**: refactor/ddd-migration  
**Author**: KC Kern, Co-Authored-By: Claude Opus 4.5  

## Summary

Fixed FolderAdapter to respect `folder_color` attribute for fixed item ordering and improved `resolvePlayables()` method to differentiate between play and queue actions.

## Files Changed

- `backend/src/2_adapters/content/folder/FolderAdapter.mjs` (+125, -17)

---

## Change Analysis

### 1. Fixed Order Preservation (folder_color behavior)

**What Changed:**
- Added check for `folder_color` attribute on folder items
- When any item has `folder_color`, skip dynamic priority sorting
- Maintains original YAML order from the watchlist file

**Code:**
```javascript
// Check if any item has folder_color - if so, maintain fixed order from YAML
// (Legacy behavior: folder_color indicates "no dynamic sorting")
const hasFixedOrder = children.some(item => item.metadata?.folder_color);

if (!hasFixedOrder) {
  // Sort by priority: in_progress > urgent > high > medium > low
  // ... existing sorting logic
}
```

**Rationale:**
- Matches legacy behavior from `backend/_legacy/routers/fetch.mjs:680`
- `folder_color` historically used as indicator for curated/fixed ordering
- Documented in `docs/reference/lists/3-data-model.md`

**‚úÖ Assessment: CORRECT**
- Properly implements legacy behavior
- Follows established pattern from previous codebase
- Comment clearly explains intent
- Non-breaking: Only affects folders with `folder_color` set

---

### 2. Enhanced resolvePlayables() Method

**What Changed:**
- Added comprehensive JSDoc documentation
- Added `options` parameter with `forceAll` flag
- Differentiated behavior between play vs queue actions
- Added helper method `_getNextPlayableFromChild()`

#### 2a. Action Type Detection

**Code:**
```javascript
// Determine action type from child's actions object
const hasPlayAction = child.actions?.play && Object.keys(child.actions.play).length > 0;
const hasQueueAction = child.actions?.queue && Object.keys(child.actions.queue).length > 0;
const hasOpenAction = child.actions?.open && Object.keys(child.actions.open).length > 0;

// Skip open/list actions - they're not playable
if (hasOpenAction && !hasPlayAction && !hasQueueAction) {
  continue;
}
```

**‚úÖ Assessment: CORRECT**
- Properly filters non-playable items (open/list actions)
- Checks for actual action data, not just existence of key
- Follows the action paradigm from `docs/reference/content/action-paradigm.md`

#### 2b. Play vs Queue Differentiation

**Code:**
```javascript
// For play action (or no explicit action type), get SINGLE next playable
// This creates variety and rotation in daily programming
if (!forceAll && hasPlayAction && !hasQueueAction) {
  const nextItem = await this._getNextPlayableFromChild(child, resolved);
  if (nextItem) {
    playables.push(nextItem);
  }
  continue;
}

// For queue action, get ALL playables
if (resolved.adapter.resolvePlayables) {
  const childPlayables = await resolved.adapter.resolvePlayables(child.id);
  playables.push(...childPlayables);
}
```

**‚úÖ Assessment: CORRECT with caveats**
- Smart distinction: play = single item, queue = all items
- Aligns with documented behavior in data model
- **Potential Issue**: When `hasPlayAction && hasQueueAction` are both true, defaults to queue behavior
  - This seems reasonable for edge cases
  - Should document this precedence explicitly

**üìù Recommendation**: Add comment explaining queue takes precedence when both actions exist

#### 2c. Next Playable Selection Logic

**New Method**: `_getNextPlayableFromChild(child, resolved)`

**Logic Flow:**
1. Get all playables from source
2. Return single items directly
3. Load watch state for the source
4. First pass: Find any in-progress item (1% - 90%)
5. Second pass: Find first unwatched item (< 90%)
6. Fallback: Return first item

**Code:**
```javascript
// Determine storage path for watch state lookup
const storagePath = adapter.getStoragePath?.(child.id) || child.source || 'media';

// First pass: find any in-progress item
for (const item of items) {
  const mediaKey = item.localId || item.id.split(':')[1];
  const state = watchState[mediaKey];
  const percent = state?.percent || 0;
  if (percent > 1 && percent < 90) {
    return item;
  }
}

// Second pass: find first unwatched item
for (const item of items) {
  const mediaKey = item.localId || item.id.split(':')[1];
  const state = watchState[mediaKey];
  const percent = state?.percent || 0;
  if (percent < 90) {
    return item;
  }
}

// All watched - return null or first item as fallback
return items[0];
```

**‚úÖ Assessment: MOSTLY CORRECT with issues**

**Issues Identified:**

1. **Storage Path Fallback Logic**
   - `adapter.getStoragePath?.(child.id) || child.source || 'media'`
   - Uses `child.source` which may not exist on child object
   - Should probably use `child.id.split(':')[0]` to extract source prefix
   - Fallback to 'media' may cause incorrect watch state lookups

2. **Media Key Extraction**
   - `item.localId || item.id.split(':')[1]`
   - Assumes ID format is always `prefix:localId`
   - Could fail for IDs without colons
   - Should have safer extraction logic

3. **Watch State Thresholds**
   - Uses hardcoded 1% and 90% thresholds
   - Should use constants `MIN_PROGRESS_THRESHOLD` and `WATCHED_THRESHOLD` defined at top of file
   - Currently defined as:
     ```javascript
     const WATCHED_THRESHOLD = 90;
     const MIN_PROGRESS_THRESHOLD = 1;
     ```

4. **Fallback Behavior Inconsistency**
   - Returns `items[0]` when all watched
   - Comment says "return null or first item"
   - Should decide: null (nothing to play) or first (replay from beginning)
   - Current behavior (first item) may cause unwanted replays

---

## Documentation Review

### Commit Message Quality
‚úÖ **GOOD**
- Clear scope: `fix(folder)`
- Descriptive summary
- Detailed body explaining both changes
- Proper co-authorship attribution

### Code Comments
‚úÖ **GOOD**
- Added comprehensive JSDoc for public method
- Inline comments explain legacy behavior
- Clear explanation of play vs queue distinction

### Missing Documentation
‚ùå **NEEDS UPDATE**
- No updates to `docs/reference/` for this behavior change
- Should document in `docs/reference/content/` or `docs/reference/lists/`
- Runtime test exists but no unit tests for new behavior

---

## Testing Analysis

### Existing Tests
- `tests/unit/suite/adapters/content/folder/FolderAdapter.test.mjs`
  - Only tests basic functionality (getList, getItem, canResolve)
  - **Does NOT test resolvePlayables()**
  - **Does NOT test folder_color behavior**

### Runtime Tests
- `tests/runtime/tv-app/multi-item-bug-investigation.mjs` exists
  - Tests FHE, The Chosen, news/cnn
  - Likely related to investigating the bugs this commit fixes

### Test Coverage Gaps
‚ùå **MISSING TESTS**
1. No unit tests for `resolvePlayables()` method
2. No unit tests for `_getNextPlayableFromChild()` helper
3. No tests for folder_color fixed ordering
4. No tests for play vs queue action differentiation
5. No tests for watch state integration in next playable selection

---

## Alignment with Project Guidelines

### Backend Instructions
‚úÖ **COMPLIANT**
- No TypeScript used (follows backend.instructions.md)
- Pure JavaScript implementation

### Code Quality
‚úÖ **GOOD**
- Follows existing patterns in FolderAdapter
- Consistent with other adapters' resolvePlayables implementations
- Proper use of async/await

### DDD Architecture
‚úÖ **CORRECT PLACEMENT**
- Changes in adapter layer (2_adapters)
- Properly uses registry for cross-adapter resolution
- Maintains separation of concerns

---

## Potential Issues & Risks

### üî¥ High Priority

1. **Storage Path Resolution Bug**
   - `child.source` may not exist, causing watch state mismatches
   - **Impact**: Wrong watch state loaded, incorrect "next up" selection
   - **Fix**: Use `child.id.split(':')[0]` or better source detection

2. **Missing Constant Usage**
   - Hardcoded thresholds instead of using defined constants
   - **Impact**: Maintainability, potential inconsistency
   - **Fix**: Use `WATCHED_THRESHOLD` and `MIN_PROGRESS_THRESHOLD`

### üü° Medium Priority

3. **ID Parsing Safety**
   - `item.id.split(':')[1]` could fail for malformed IDs
   - **Impact**: Runtime errors in edge cases
   - **Fix**: Add null checks or regex validation

4. **Fallback Behavior Clarity**
   - Unclear whether returning first item when all watched is desired
   - **Impact**: May cause unwanted content replays
   - **Fix**: Document intended behavior, possibly return null instead

5. **Test Coverage**
   - No unit tests for new functionality
   - **Impact**: Regressions could be introduced
   - **Fix**: Add comprehensive unit tests

### üü¢ Low Priority

6. **JSDoc Parameter Typing**
   - Uses `@param {Object}` without detailed property specs
   - **Impact**: Reduced IDE autocomplete/validation
   - **Fix**: Expand JSDoc with property details

7. **Action Precedence Documentation**
   - When both play and queue actions exist, behavior unclear
   - **Impact**: Confusion about edge case handling
   - **Fix**: Add comment explaining precedence

---

## Recommendations

### Immediate Fixes Required

1. **Fix storage path resolution:**
```javascript
const storagePath = adapter.getStoragePath?.(child.id) || 
                   child.id.split(':')[0] || 
                   'media';
```

2. **Use defined constants:**
```javascript
// Replace hardcoded values
if (percent > MIN_PROGRESS_THRESHOLD && percent < WATCHED_THRESHOLD) {
  return item;
}
// ...
if (percent < WATCHED_THRESHOLD) {
  return item;
}
```

3. **Add ID parsing safety:**
```javascript
const mediaKey = item.localId || (item.id.includes(':') ? item.id.split(':')[1] : item.id);
```

4. **Clarify fallback behavior:**
```javascript
// All watched - return first item to allow replay
// Alternative: return null to indicate nothing new to play
return items[0]; // or return null;
```

### Follow-up Work

1. **Add Unit Tests**
   - Test `resolvePlayables()` with play vs queue actions
   - Test `_getNextPlayableFromChild()` with various watch states
   - Test folder_color fixed ordering behavior

2. **Update Documentation**
   - Document folder_color fixed ordering in reference docs
   - Document play vs queue behavior in action paradigm docs
   - Add examples of resolvePlayables usage

3. **Consider Refactoring**
   - `_getNextPlayableFromChild()` is quite long (50+ lines)
   - Could extract watch state lookup logic to separate method
   - Could extract media key determination logic

---

## Overall Assessment

**Grade: B+ (Good with issues)**

### Strengths ‚úÖ
- Correctly implements legacy folder_color behavior
- Smart play vs queue differentiation aligns with use cases
- Well-commented and documented via JSDoc
- Follows DDD architecture and project patterns
- Non-breaking changes

### Weaknesses ‚ùå
- Storage path resolution has potential bugs
- Doesn't use defined constants
- Missing unit tests for new functionality
- ID parsing lacks error handling
- No documentation updates

### Verdict
The commit addresses real bugs and improves functionality, but has implementation issues that should be fixed before merging to main. The logic is sound, but the execution has edge case handling problems and missing test coverage.

**Recommendation**: 
1. Apply immediate fixes for storage path, constants, and ID parsing
2. Add unit tests
3. Then merge to main
4. Follow up with documentation updates

---

## Related Context

### Legacy Behavior References
- `backend/_legacy/routers/fetch.mjs:680` - Original folder_color check
- Uses: `const noSort = itemsFromList.some(item => item?.folder_color);`

### Documentation
- `docs/reference/lists/3-data-model.md:169` - Documents folder_color field
- `docs/reference/content/action-paradigm.md` - Action types and usage

### Recent Related Commits
- cd1fa8c6 - fix(filesystem): handle single files in resolvePlayables
- 8f42b48a - feat(adapters): add LocalContentAdapter resolvePlayables
- 00cd8bfe - fix(plex): extract label helper and cache show labels

### Test Files
- `tests/runtime/tv-app/multi-item-bug-investigation.mjs` - Runtime testing
- `tests/unit/suite/adapters/content/folder/FolderAdapter.test.mjs` - Unit tests (needs expansion)
